#!/bin/zsh

set -eu

local -r commandName="$(basename "$0")"
local -r utilsDir="$(cd "$(dirname $0)" && pwd -L)"
local -r repoDir="$(dirname "$utilsDir")"
local -r postgresBranch=$(cat "${repoDir}/.postgres-branch")
local -r assetsDir="${repoDir}/assets"
local -r sourcesDir="${repoDir}/Sources"
local -r pqDir="${sourcesDir}/PQ"

local ____postgresCopyrightContent=""
function __postgresCopyright() {
  if [[ -z "$____postgresCopyrightContent" ]]; then
    ____postgresCopyrightContent=$(curl -sSL "https://raw.githubusercontent.com/postgres/postgres/${postgresBranch}/COPYRIGHT")
  fi
  echo "$____postgresCopyrightContent"
}


function update-grammars() {
  # Download gram.y file from PostgreSQL (mirror) repository
  # and let 'bison' parse the file to make it easy to read.

  local -r grammarsDir="${assetsDir}/grammars"
  local -r gramyURL="https://raw.githubusercontent.com/postgres/postgres/${postgresBranch}/src/backend/parser/gram.y"
  local -r gramyPath="${grammarsDir}/gram.${postgresBranch}.y"
  local -r gramOutputPath="${grammarsDir}/gram.${postgresBranch}.output"
  local -r gramOutputExtractedPath="${grammarsDir}/gram.${postgresBranch}.output.extracted.txt"

  set -x
  mkdir -p "$grammarsDir"
  curl -sSL "$gramyURL" >"$gramyPath"
  cd "$grammarsDir"
  bison -v "gram.${postgresBranch}.y"
  { set +x; } 2>/dev/null

  if [[ -f "$gramOutputPath" ]]; then
    sed -n '/Grammar/,/Terminals, with rules where they appear/p' "$gramOutputPath" | \
      grep -E '^[[:space:]]*[0-9]+' | \
      sed -E 's/^[[:space:]]*[0-9]+//g' >"$gramOutputExtractedPath"
  fi

  set -x
  ls -ahl .
}

function update-pg-types() {
  # Download pg_type.dat file from PostgreSQL (mirror) repository
  # and convert it to json/swift files.

  local -r pgTypesDir="${assetsDir}/pg-types"
  local -r pgTypeDatURL="https://raw.githubusercontent.com/postgres/postgres/${postgresBranch}/src/include/catalog/pg_type.dat"
  local -r pgTypeDatPath="${pgTypesDir}/pg_type.dat"
  local -r perlImplPath="${utilsDir}/update-pg-types-converter-impl.pl"
  local -r pgTypeJSONPath="${pgTypesDir}/pg_type.json"
  local -r pgTypeSwiftPath="${pgTypesDir}/pg_type.swift"

  mkdir -p "$pgTypesDir"

  echo "Downloading $pgTypeDatURL..."
  curl -sSL "$pgTypeDatURL" >"$pgTypeDatPath"

  echo "Generating a JSON file to $pgTypeJSONPath"
  perl "$perlImplPath" "$pgTypeDatPath" --json | jq . >"$pgTypeJSONPath"

  echo "Generating a Swift file to $pgTypeSwiftPath"
  echo "// This file is autogenerated from ${pgTypeDatURL}." >"$pgTypeSwiftPath"
  echo "// Your modification to this file will be lost after executing 'update-pg-types'." >>"$pgTypeSwiftPath"
  echo >>"$pgTypeSwiftPath"
  echo "// PostgreSQL is released under the PostgreSQL License:" >>"$pgTypeSwiftPath"
  echo "/*" >>"$pgTypeSwiftPath"
  echo "$(__postgresCopyright)" >>"$pgTypeSwiftPath"
  echo "*/" >>"$pgTypeSwiftPath"
  echo >>"$pgTypeSwiftPath"
  perl "$perlImplPath" "$pgTypeDatPath" --swift >>"$pgTypeSwiftPath"

  echo "Done."
}

case "$commandName" in
update-grammars |\
update-pg-types )
  $commandName $@
;;
*)
  echo "Unexpected command name: $commandName" 1>&2
;;
esac