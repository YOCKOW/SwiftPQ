#!/bin/zsh

set -eu

local -r commandName="$(basename "$0")"
local -r utilsDir="$(cd "$(dirname $0)" && pwd -L)"
local -r repoDir="$(dirname "$utilsDir")"
local postgresBranch=$(cat "${utilsDir}/.postgres-branch")
local -r assetsDir="${repoDir}/assets"


function update-grammars() {
  # Download gram.y file from PostgreSQL (mirror) repository
  # and let 'bison' parse the file to make it easy to read.

  local -r grammarsDir="${assetsDir}/grammars"
  local -r gramyURL="https://raw.githubusercontent.com/postgres/postgres/${postgresBranch}/src/backend/parser/gram.y"
  local -r gramyPath="${grammarsDir}/gram.${postgresBranch}.y"
  local -r gramOutputPath="${grammarsDir}/gram.${postgresBranch}.output"
  local -r gramOutputExtractedPath="${grammarsDir}/gram.${postgresBranch}.output.extracted.txt"

  set -x
  mkdir -p "$grammarsDir"
  curl -sSL "$gramyURL" >"$gramyPath"
  cd "$grammarsDir"
  bison -v "gram.${postgresBranch}.y"
  { set +x; } 2>/dev/null

  if [[ -f "$gramOutputPath" ]]; then
    sed -n '/Grammar/,/Terminals, with rules where they appear/p' "$gramOutputPath" | \
      grep -E '^[[:space:]]*[0-9]+' | \
      sed -E 's/^[[:space:]]*[0-9]+//g' >"$gramOutputExtractedPath"
  fi

  set -x
  ls -ahl .
}

function update-pg-types() {
  # Download pg_type.dat file from PostgreSQL (mirror) repository
  # and convert it to json file.

  local -r pgTypesDir="${assetsDir}/pg-types"
  local -r pgTypeDatURL="https://raw.githubusercontent.com/postgres/postgres/${postgresBranch}/src/include/catalog/pg_type.dat"
  local -r pgTypeDatPath="${pgTypesDir}/pg_type.dat"
  local -r perlImplPath="${utilsDir}/update-pg-types-converter-impl.pl"
  local -r pgTypeJSONPath="${pgTypesDir}/pg_type.json"

  set -x
  mkdir -p "$pgTypesDir"
  curl -sSL "$pgTypeDatURL" >"$pgTypeDatPath"
  perl "$perlImplPath" "$pgTypeDatPath" --json | jq . >"$pgTypeJSONPath"
  { set +x; } 2>/dev/null
}

case "$commandName" in
update-grammars |\
update-pg-types )
  $commandName $@
;;
*)
  echo "Unexpected command name: $commandName" 1>&2
;;
esac